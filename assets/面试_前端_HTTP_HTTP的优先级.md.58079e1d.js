import{_ as e,c as a,o as t,a as r}from"./app.46505ed0.js";const x=JSON.parse('{"title":"强缓存","description":"","frontmatter":{},"headers":[{"level":2,"title":"Expires","slug":"expires","link":"#expires","children":[]},{"level":2,"title":"Cache-Control","slug":"cache-control","link":"#cache-control","children":[]},{"level":2,"title":"ETag","slug":"etag","link":"#etag","children":[]},{"level":2,"title":"对比HTTP1.x","slug":"对比http1-x","link":"#对比http1-x","children":[]}],"relativePath":"面试/前端/HTTP/HTTP的优先级.md"}'),l={name:"面试/前端/HTTP/HTTP的优先级.md"},i=r(`<h1 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-hidden="true">#</a></h1><p>Expires(HTTP/1.0)和Cache-Control(HTTP1.1)，其中Cache-Control优先级高于Expires 位于请求/响应头</p><h2 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-hidden="true">#</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>由于Expires受制于客户端时间，修改客户端时间可能导致缓存失效</p><h2 id="cache-control" tabindex="-1">Cache-Control <a class="header-anchor" href="#cache-control" aria-hidden="true">#</a></h2><p>请求/响应头，缓存控制字段，精确控制缓存策略 这里涉及到的字段是max-age,Cache-Control还有其他字段</p><h1 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h1><ol><li>没有 Cache-Control 和 Expires</li><li>Cache-Control 和 Expires 过期</li><li>设置了 no-cache</li></ol><p>如果有更新即更新缓存 200 没有缓存则更新浏览器缓存有效期 304</p><h2 id="etag" tabindex="-1">ETag <a class="header-anchor" href="#etag" aria-hidden="true">#</a></h2><h2 id="对比http1-x" tabindex="-1">对比HTTP1.x <a class="header-anchor" href="#对比http1-x" aria-hidden="true">#</a></h2><p>使用HTTP/1.x，浏览器可以完全控制资源加载顺序。每个连接一次只能支持一个资源请求，服务器会尽快返回请求的内容。浏览器可以通过决定何时请求资源以及打开多少个并行连接来安排请求</p><p>1.HTTP 协议老的标准是HTTP/1.0，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。即无状态，并且HTTP1的连接无法复用导致每一次请求都会经历三次握手和四次挥手</p><ol start="2"><li></li></ol>`,15),s=[i];function n(c,o,h,p,d,T){return t(),a("div",null,s)}const C=e(l,[["render",n]]);export{x as __pageData,C as default};
